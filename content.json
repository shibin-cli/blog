{"meta":{"title":"Web前端学习笔记","subtitle":"Web前端学习笔记","description":"学习笔记","author":"Shibin","url":"https://shibin-cli.github.io/blog","root":"/blog/"},"pages":[{"title":"404","date":"2021-01-01T09:00:00.000Z","updated":"2021-07-22T02:06:46.989Z","comments":true,"path":"404/index.html","permalink":"https://shibin-cli.github.io/blog/404/index.html","excerpt":"","text":""},{"title":"about","date":"2021-01-01T09:00:00.000Z","updated":"2021-07-22T02:06:46.989Z","comments":true,"path":"about/index.html","permalink":"https://shibin-cli.github.io/blog/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-01-01T09:00:00.000Z","updated":"2021-07-22T02:06:46.989Z","comments":true,"path":"categories/index.html","permalink":"https://shibin-cli.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-01-01T09:00:00.000Z","updated":"2021-07-22T02:06:46.989Z","comments":true,"path":"tags/index.html","permalink":"https://shibin-cli.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Rollup","slug":"rollup","date":"2021-07-18T00:00:00.000Z","updated":"2021-07-22T02:06:46.989Z","comments":true,"path":"2021/07/18/rollup/","link":"","permalink":"https://shibin-cli.github.io/blog/2021/07/18/rollup/","excerpt":"","text":"rollup的基本使用Rollup是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码,Rollup 对代码模块使用新的标准化格式，这些标准都包含在 JavaScript 的 ES6 版本中 npm i rollup -D 使用rollup编译文件 浏览器环境 rollup main.js --file bundle.js --format iife 编译node rollup main.js --file bundle.js --format cjs 使用rollup配置文件 export default &#123; // 入口文件 input: 'src/main.js', output: &#123; // 输出文件 file: 'dist/bundle.js', // 输出文件的格式 format: 'iife' &#125; &#125; Rollup插件插件是Rollup唯一的拓展途径 下面以rollup-plugin-json为例 + import json from 'rollup-plugin-json' export default &#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.js', format: 'iife' &#125;, + plugins:[ + json() + ] &#125; 使用rollup加载npm模块rollup默认只支持路径加载，可以通过使用@rollup/plugin-node-resolve像webpack一样通过模块名称倒入模块 + import resolve from '@rollup/plugin-node-resolve' export default &#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.js', format: 'iife' &#125;, plugins:[ + resolve() ] &#125; 使rollup支导入commonjs模块+ import commonjs from '@rollup/plugin-commonjs' export default &#123; input: 'src/main.js', output: &#123; file: 'dist/bundle.js', format: 'iife' &#125;, plugins:[ + commonjs() ] &#125; 代码拆分Rollup已经支持动态导入 import('./a').then(&#123;sum&#125; => &#123; console.log(sum) &#125;) 注意，这里umd和iife不支持代码拆分 export default &#123; input: 'src/main.js', output: &#123; format: 'amd', dir: 'dist' &#125; &#125; 多入口打包Rollup多入口打包的写法与Webpack类似 export default &#123; input: ['src/a.js', 'src/b.js'], output: &#123; format: 'amd', dir: 'dist' &#125; &#125; export default &#123; input: &#123; main: './a.js', b: './b.js' &#125;, output: &#123; format: 'amd', dir: 'dist' &#125; &#125; Rollup选用原则 加载非ESM的第三方模块比较复杂 浏览器环境中，代码拆分功能依赖AMD库（代码拆分不支持UMD和IIFE）","categories":[{"name":"前端","slug":"前端","permalink":"https://shibin-cli.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"模块化开发","slug":"模块化开发","permalink":"https://shibin-cli.github.io/blog/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://shibin-cli.github.io/blog/tags/JavaScript/"}]},{"title":"JS模块化开发","slug":"module","date":"2021-07-10T00:00:00.000Z","updated":"2021-07-22T02:06:46.989Z","comments":true,"path":"2021/07/10/module/","link":"","permalink":"https://shibin-cli.github.io/blog/2021/07/10/module/","excerpt":"","text":"模块化开发的演变过程按文件划分 每个功能单独放在不同的文件中 所有模块都在全局去工作，完全依赖约定存在 污染全局作用域 命名冲突 无法管理模块的依赖关系命名空间方式 每个模块暴露一个全局对象，所有模块成员都挂载到对象中 虽然减少了全局污染，但是全局污染、命名冲突、依赖关系依然没有解决立即执行函数（IIFE） 实现了内部私有的成员 通过传参传入依赖项 (function($)&#123; ... window.xxx = &#123; xxx:... &#125; &#125;)(jq) AMD异步模块定义规范，通过异步方式加载模块，模块加载不影响后面代码执行，所有依赖模块执行的代码，放在回调函数中，异步模块加载完毕后会执行回调函数 require([module]callback) 目前主要有两个JavaScript库实现了AMD规范 requireJs 和cur 存在问题 需要引入第三方库，增加额外的代码 请求js文件频繁CommonJS 每个模块是单独的文件 每个模块的有自己的作用域 通过module.exports导出模块；通过require导入模块，后缀名默认为.js，多次require 加载模块是同步的 http://javascript.ruanyifeng.com/nodejs/module.html 由于CommonJS是同步的，所以不适合浏览器环境，在node环境中，模块都是本地文件，加载速度比较快 CMD(sea.js )类似CommonJS规范，后来被requirejs兼容了 define(function(require, exports, module) &#123; // 模块代码 &#125;); ES Modules 标准化的Module特性 自动使用严格模式 export 导出，import导入 export导出的不是对象，而是特定的代码 import 导入只会加载导入的方法，没有导入的方法不会加载 编译时加载 每个文件都有自己单独的作用域模块标椎规范 NodeJS 采用CommonJS规范 浏览器采用ES Modules ES Mudules","categories":[{"name":"前端","slug":"前端","permalink":"https://shibin-cli.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"模块化开发","slug":"模块化开发","permalink":"https://shibin-cli.github.io/blog/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://shibin-cli.github.io/blog/tags/JavaScript/"}]},{"title":"requirejs使用","slug":"requirejs","date":"2021-07-10T00:00:00.000Z","updated":"2021-07-22T02:06:46.989Z","comments":true,"path":"2021/07/10/requirejs/","link":"","permalink":"https://shibin-cli.github.io/blog/2021/07/10/requirejs/","excerpt":"","text":"首先下载requirejs或直接引用cdn 官方文档 阮一峰的网络日志 下面部分内容是看了阮一峰大神的文章后写的 引入requirejs&lt;script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.js\">&lt;/script> 也可以这样引入，data-main属性的作用是，指定网页程序的主模块。require.js默认的文件后缀名是js，.js后缀可以不写 &lt;script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.js\" data-main=\"js/main\">&lt;/script> 主模块的写法 require(['moduleA', 'moduleB', 'moduleC'], function (moduleA, moduleB, moduleC) &#123; // some code here &#125;); require函数接收两个参数 第一个参数是所依赖的模块，类型是数组 第二个参数是回调函数，引入的所有模块加载成功后会执行 回调函数所对应的参数依次对应所导入的模块 模块的加载require.config 可以对模块的加载行为进行自定义。 参数是个对象 paths 指定各个模块的加载路径 模块路径也可以是个网址 baseUrl 指定模块的根路径require.config(&#123; paths: &#123; \"jquery\": \"jquery.min\", \"underscore\": \"underscore.min\", \"backbone\": \"backbone.min\" &#125; &#125;); 指定模块的根路径require.config(&#123; // 指定模块的根路径 baseUrl: \"js/lib\", paths: &#123; \"jquery\": \"jquery.min\", \"underscore\": \"underscore.min\", \"backbone\": \"backbone.min\" &#125; &#125;); 模块路径也可以是个网址require.config(&#123; paths: &#123; // 模块路径也可以是个网址 \"jquery\": \"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min\" &#125; &#125;); require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个优化工具，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。 AMD模块的写法require.js加载的模块，采用AMD规范。 模块必须采用特定的define方法来定义 // math.js define(function () &#123; var add = function (x, y) &#123; return x + y; &#125;; return &#123; add: add &#125;; &#125;); 加载模块 require(['math'], function (math)&#123; console.log(math.add(1,1)); &#125;); 当依赖其他模块时，define函数的第一个参数，就是所依赖的模块且必须是一个数组 CMD模块写法requirejs兼容了CMD规范的写法（类CommonJS的写法） 声明模块，写法1 define(function (require, exports, module) &#123; exports.add = (a, b) => &#123; return a + b &#125; &#125;); 写法2 define(function (require, exports, module) &#123; module.exports = (a, b) => &#123; return a + b &#125; &#125;); 依赖项的模块 define(\"foo/title\", [\"my/cart\", \"my/inventory\"], function(cart, inventory) &#123; //Define foo/title object in here. &#125; ); 导入模块 define(function(require, exports, module) &#123; var a = require('a'), b = require('b'); //Return the module value return function () &#123;&#125;; &#125; );","categories":[{"name":"前端","slug":"前端","permalink":"https://shibin-cli.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"模块化开发","slug":"模块化开发","permalink":"https://shibin-cli.github.io/blog/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://shibin-cli.github.io/blog/tags/JavaScript/"}]},{"title":"如何使用模块联邦落地微前端","slug":"moduleFederation","date":"2021-07-09T00:00:00.000Z","updated":"2021-07-22T02:06:46.989Z","comments":true,"path":"2021/07/09/moduleFederation/","link":"","permalink":"https://shibin-cli.github.io/blog/2021/07/09/moduleFederation/","excerpt":"","text":"目前微前端的落地方案 自组织模式 基座模式 模块加载模式 模块加载模式没有中心容器，可以将任意一个微应用当做项目入口，微应用与微应用之间相互串联，这种模式也叫做去中心化模式 webpack5引进了Module Federation（模块联邦，简称mf），mf 实际想要做的事，便是把多个无相互依赖、单独部署的应用合并为一个。一个模块既可以导出给其他模块使用，又可以导入一个其他模块 无论是 single-spa 还是 qiankun，加载不同模块，都需要有一个容器中心来承载，而在 mf 中，没有且也不需要容器中心（每个应用都可以导出又导入） Module Federation在webpack中的使用项目A，导出应用 const path = require('path') const HtmlWebpackPlugin = require('html-webpack-plugin') const Mfp = require('webpack').container.ModuleFederationPlugin module.exports = &#123; entry: './src/main.js', output: &#123; filename: './bundle.js', path: path.resolve(__dirname, 'dist1') &#125;, mode: 'development', devServer: &#123; port: 3001, &#125;, // 插件 plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html' &#125;), new Mfp(&#123; // 对外提供的打包后的⽂件名（引⼊时使⽤） filename: 'em.js', // 当前微应⽤名称 name: 'em', // 暴露的应用内具体模块 exposes: &#123; // 名称： 代码路径 './exposesModule': './src/exposesModule.js', &#125; &#125;) ] &#125; 在项目A的导出文件中提供了一个方法 export function sum(a, b) &#123; return a + b &#125; 项目B，导入应用 // 项目B const path = require('path') const HtmlWebpackPlugin = require('html-webpack-plugin') const Mfp = require('webpack').container.ModuleFederationPlugin module.exports = &#123; mode: 'development', entry: './src/index.js', output: &#123; filename: './bundle.js', path: path.resolve(__dirname, 'dist2') &#125;, devServer: &#123; port: 3002, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html' &#125;), new Mfp(&#123; // 导⼊模块 remotes: &#123; // 导⼊后给模块起个别名：“微应⽤名称@地址/导出的⽂件名” appone: 'em@http://localhost:3001/em.js' &#125; &#125;) ] &#125; 项目B中使用项目A中提供的方法 import('appone/exposesModule').then(res => &#123; console.log(res.sum(1,2)) &#125;) 启动两个项目后，可以看到控制台会打印出3这个结果 项目A，打包后会生成 bundle.js em.js 对外提供的打包后的⽂件，代码中会导入 src_exposesModule_js.bundle.js index.html src_exposesModule_js.bundle.js 提供具体模块的文件 项目B会生成 bundle.js 代码中会导入http:&#x2F;&#x2F;localhost:3001&#x2F;em.js，也就是上面的em.js文件 index.html 就这样，实现了项目B导入项目A中的模块 通过 Module Federation，任意的一个应用都可以作为微应用，为其他应用提供模块，增加了项目的灵活性，但没有统一的基座中心，每个应用维护就非常重要，增加了开发的难度。在项目数量庞大的情况下，管理成本就会提升。","categories":[{"name":"前端","slug":"前端","permalink":"https://shibin-cli.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"模块化开发","slug":"模块化开发","permalink":"https://shibin-cli.github.io/blog/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"},{"name":"微前端","slug":"微前端","permalink":"https://shibin-cli.github.io/blog/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"}]},{"title":"前端常用工具","slug":"tools","date":"2021-07-03T00:00:00.000Z","updated":"2021-07-22T02:06:46.989Z","comments":true,"path":"2021/07/03/tools/","link":"","permalink":"https://shibin-cli.github.io/blog/2021/07/03/tools/","excerpt":"","text":"移动端H5页面调试移动端H5页面调试工具 vconsole 查看浏览器的兼容性 JS/CSS/HTML 兼容性问题都可以查看 https://canisue.com/","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://shibin-cli.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"JavaScript性能优化","slug":"performance","date":"2021-01-15T00:00:00.000Z","updated":"2021-07-22T02:06:46.989Z","comments":true,"path":"2021/01/15/performance/","link":"","permalink":"https://shibin-cli.github.io/blog/2021/01/15/performance/","excerpt":"","text":"内存管理为什么需要使用内存管理 内存管理介绍内存: 有可读写单元组成，表示一片可操作空间 管理：人为的去操作一片空间的申请、使用和释放 内存管理：开发者主动申请空间、使用空间、释放空间 管理流程： 申请 -&gt; 管理 -&gt; 释放 // 申请 let obj = &#123;&#125; // 使用 obj.name = 'aa' // 释放 obj = null Javascript中的垃圾回收 JavaScript中内存管理是自动的 对象在不被引用时时垃圾、对象不能从根上访问到时时垃圾 JavaScript中的可达对象 可以访问到的对象就是可达对象（引用、作用域链） 可达的标准就是从根出发是否能够被找到 JavaScript中的根就可以理解为时全局变量对象 JavaScript中的引用与可达 let obj = &#123; name: 'JavaScript' &#125; let obj2 = obj obj = null 上面代码中obj虽然obj赋值为null，但是obj2还在引用obj对象，所以obj依然是可达的 GC算法 GC就是垃圾回收机制的简写 GC可以找到内存中的垃圾、并释放和回收空间 GC中的垃圾是什么 程序中不在需要使用的对象 程序中不能再访问到的对象 GC算法是什么 GC算法是一种机制，垃圾回收器完成具体的工作 工作的内容就是查找垃圾释放空间、回收空间 算法是工作时查找和回收所遵循的规则 常见的GC算法 引用计数 标记清除 标记整理 分代回收 引用计数 引用计数的核心就是设置引用数，判断当前引用计数是否位0 引用关系发生改变时修改引用数字 引用数字为0时，立即回收 引用计数的优点 发现垃圾时立即回收 最大限度的减少程序的暂停 引用计数的缺点 无法回收循环引用的对象 资源开销大 下面代码就会引起循环引用 function fn() &#123; const obj1 = &#123;&#125; const obj2 = &#123;&#125; obj1.name = obj2 obj2.name = obj1 &#125; fn() 标记清除分标记和清除两个阶段完成 遍历所有对象找标记活动对象（查询所有的可达对象进行标记） 遍历所有对象清除没有标记的对象 回收相应的空间 标记清除的优点 可以解决前面提到的对象引用的问题 标记清除的缺点 空间的碎片化 不能立即回收对象标记整理 标记整理可以看做时标记清除的增强 标记阶段的操作和标记清除一致 清除阶段会先执行整理，移动对象位置 优点 减少空间碎片化 不能立即回收对象V8 V8是一款主流的JavaScript执行引擎 采用即时编译 V8内存设限 V8垃圾回收策略采用分代回收，内存分为新生代和老生代，针对不同对象采用不同的算法 新生代对象采用GC算法 V8常用的GC算法 分代回收 空间复制 标记清除 标记整理 标记增量V8内存分配 V8内存空间一分为二 小空间用于存储新生代对象（32M | 16M）,新生代指的是存活时间较短的对象 新生代对象回收实现 回收过程采用复制算法+标记整理 新生代存储分为两个等大小空间 使用空间为from,空闲空间为to 活动对象存储与from空间，标记整理后活动对象拷贝至To from与to交换空间完成释放 回收过程细节说明 拷贝过程中会出现晋升，晋升就是将新生代对象移动至老生代 一轮GC还存活的的新生代需要晋升 To空间的使用率超过25%需要晋升 老生代对象回收老生代对象指的就是存活时间较长的对象 老生代对象限制：64位操作系统1.4G、32位操作系统700M 回收 只要采用标记清除、标记整理、标记增量算法 首先采用标记清除完成垃圾回收空间的清除 采用标记整理进行空间优化（晋升时触发） 采用增量标记进行效率优化 程序触发垃圾回收后，会遍历对象进行标记，之后标记和程序执行交替进行（将标记操作分成了多步，程序停顿的时间拆分成了多个小段），标记操作完成后，完成清除，程序继续执行 新生代与老生代回收对比 新生代区域垃圾回收使用空间交换时间 老生代区域垃圾回收不适合复制算法 PerformanceGC的目的是为了实现内存空间的良性循环，Performance提供多种监控方式 打开浏览器控制台，选择Performance，开启录制功能 内存问题的外在表现 页面出现延迟加载或经常性暂停 页面出现出现持续糟糕的性能 页面的性能随着时间延长越来越差 监控内存的几种方式界定内存问题的标准 内存泄漏：内存使用持续升高 内存膨胀：在多数设备上都存在性能问题 频繁的垃圾回收：通过内存变化图进行分析 内存监控的几种方式 浏览器的任务管理器（shift + esc） Timeline时序图记录 堆快照查找分离DOM（浏览器控制台&gt;内存） 频繁的垃圾回收 timtLine中频繁的上升或下降 任务管理器数据频繁的增加减少 代码优化可通过 https://jsperf.com/ 对代码进行性能测试 慎用全局变量为什么要慎用 全局变量定义在全局执行上下文，是所有作用域链的顶端 全局执行上下文一直存在于上下文执行栈，直到程序退出 如果某个局部作用域出现了同名变量则会遮蔽或污染全局","categories":[],"tags":[{"name":"性能","slug":"性能","permalink":"https://shibin-cli.github.io/blog/tags/%E6%80%A7%E8%83%BD/"}]},{"title":"jsdoc","slug":"jsdoc","date":"2021-01-10T00:00:00.000Z","updated":"2021-07-22T02:06:46.989Z","comments":true,"path":"2021/01/10/jsdoc/","link":"","permalink":"https://shibin-cli.github.io/blog/2021/01/10/jsdoc/","excerpt":"","text":"类型注释 https://jsdoc.app/ /** * @param &#123;number&#125; a param1 * @param &#123;number&#125; b param2 * @returns &#123;number&#125; * */ function fn(a, b) &#123; return a + b &#125; let a = fn() 常见的类型注释 @type 变量类型 @param(或@params或@argument) 参数类型 returns(或returns) 返回值类型 typedef 相当于ts中的type Status = &quot;open&quot; | &quot;close&quot; @callback 回调函数 https://jsdoc.app/tags-callback.html @template @class（@constructor） @this 函数内部this指向 @extends(@arguments) enum /**@typedef &#123;'open'|'close'&#125; Status */ /**@type &#123;Status&#125; */ const a = 'close' 在webpack中使用 /** @type &#123;import('webpack').Configuration&#125; */ module.exports = &#123; ... &#125;","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://shibin-cli.github.io/blog/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://shibin-cli.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Lerna","slug":"lerna","date":"2021-01-10T00:00:00.000Z","updated":"2021-07-22T02:06:46.989Z","comments":true,"path":"2021/01/10/lerna/","link":"","permalink":"https://shibin-cli.github.io/blog/2021/01/10/lerna/","excerpt":"","text":"Lerna 是一个优化基于git+npm的多package项目管理工具 优势 大幅度减少重复操作 提升操作单标椎化 原生脚手架的痛点 重复操作，多个package 本地link 依赖安装 单元测试 代码提交 代码发布 版本一致性 版本一致性 发布后相互依赖版本升级 package越多，管理复杂度就越高 Lerna的使用npm install lerna -g # 初始化lerna lerna init # 创建一个包 lerna create core # 安装依赖 lerna add xxx # 删除依赖 lerna clean # 给指定package安装依赖 lerna add vue packages/core # 重新安装依赖 lerna bootstrap # 本地项目相互依赖 lerna link # 执行npm script lerna run # 发布 lerna publish lerna源码首先从github上下载源码 https://github.com/lerna/lerna 然后安装依赖 npm install 如果无法安装成功可以修改.npmrc文件，修改镜像地址为淘宝镜像 https://registry.npm.taobao.org/ # just in case a private registry is configured in ~&#x2F;.npmrc registry &#x3D; https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F; 通过查看package.json文件可以看出入口文件为core/lerna/cli.js &#123; ... \"bin\": &#123; \"lerna\": \"core/lerna/cli.js\" &#125;, ... &#125; 在core/lerna/cli.js中引入了core/lerna/cli.js #!/usr/bin/env node \"use strict\"; /* eslint-disable import/no-dynamic-require, global-require */ const importLocal = require(\"import-local\"); if (importLocal(__filename)) &#123; require(\"npmlog\").info(\"cli\", \"using local version of lerna\"); &#125; else &#123; require(\".\")(process.argv.slice(2)); &#125; 我们可以看到很多模块导入时通过@lerna/xxx导入的 const cli = require(\"@lerna/cli\"); 它导入的并不是外面npm安装的模块，我们可以查看当前目录下的package.json文件,在这里配置了模块的路径为本地路径，当模块发布时,我们也不必担心，lerna会自动处理模块的导入 &#123; ... \"dependencies\": &#123; \"@lerna/add\": \"file:../../commands/add\", \"@lerna/bootstrap\": \"file:../../commands/bootstrap\", \"@lerna/changed\": \"file:../../commands/changed\", \"@lerna/clean\": \"file:../../commands/clean\", ... &#125; &#125; yargslerna中使用了yargs这个模块，所以首先要了解yargs如何使用 实现一个yargs最简单的脚手架#! /usr/bin/env node const yargs = require('yargs') // 同事还会将掺入的参数解析成对象 yargs(process.argv.slice(2)).argv // 后者可以写成 // yargs().parse(process.argv.slice(2)) 然后输入 cli --help 就会出现 选项： --help 显示帮助信息 [布尔] --version 显示版本号 [布尔] yargs常用的方法对应方法的文档可以查看 https://github.com/yargs/yargs/blob/master/docs/api.md const argv = process.argv.slice(2) const cli = yargs() const constext = &#123; cliVersion: pkg.version &#125; cli.usage('cli-test [command] &lt;options>') .alias('v', 'version') //别名 .alias('h', 'help') // 定义用户输出的最小长度和最大长度 // https://github.com/yargs/yargs/blob/master/docs/api.md#demandCommand .demandCommand(1, 'A command is required') .wrap(cli.terminalWidth()) // 控制台最后输出的内容 .epilogue(dedent` das aa asd`) // 命令 .command('init [name]', 'Do it in a project', yargs => &#123; yargs .option('name', &#123; type: 'string', describe: 'Name of a project' &#125;) &#125;, argv => &#123; console.log(argv) &#125;) .recommendCommands() .fail((err) => &#123; console.log(err) &#125;) .command(&#123; command: 'list', aliases: ['ls', 'la', 'll'], builder: yargs => &#123; console.log(yargs) return &#123;&#125; &#125;, handler: argv => &#123; console.log(argv) &#125; &#125;) .options(&#123; debug: &#123; type: 'boolean', describe: 'Boostrap debug mode', alias: 'd' &#125; &#125;) // 选项 如vue create a -r=https://registry.npm.taobao.org/ .option('registry', &#123; type: 'string', describe: 'Define global registry', alias: 'r' &#125;) //命令在控制台的分类 .group(['debug'], 'Dev Options') .strict() // constext会和argv进行合并 .parse(argv, constext) lerna的初始化过程lerna的入口文件core/lerna/cli.js #!/usr/bin/env node \"use strict\"; /* eslint-disable import/no-dynamic-require, global-require */ const importLocal = require(\"import-local\"); if (importLocal(__filename)) &#123; require(\"npmlog\").info(\"cli\", \"using local version of lerna\"); &#125; else &#123; // 引入的当前目录下的index.js require(\".\")(process.argv.slice(2)); &#125; core/lerna/index.js，该文件中主要是注册了一些命令 \"use strict\"; const cli = require(\"@lerna/cli\"); const addCmd = require(\"@lerna/add/command\"); const bootstrapCmd = require(\"@lerna/bootstrap/command\"); const changedCmd = require(\"@lerna/changed/command\"); const cleanCmd = require(\"@lerna/clean/command\"); const createCmd = require(\"@lerna/create/command\"); const diffCmd = require(\"@lerna/diff/command\"); const execCmd = require(\"@lerna/exec/command\"); const importCmd = require(\"@lerna/import/command\"); const infoCmd = require(\"@lerna/info/command\"); const initCmd = require(\"@lerna/init/command\"); const linkCmd = require(\"@lerna/link/command\"); const listCmd = require(\"@lerna/list/command\"); const publishCmd = require(\"@lerna/publish/command\"); const runCmd = require(\"@lerna/run/command\"); const versionCmd = require(\"@lerna/version/command\"); const pkg = require(\"./package.json\"); module.exports = main; function main(argv) &#123; const context = &#123; lernaVersion: pkg.version, &#125;; return cli() .command(addCmd) .command(bootstrapCmd) .command(changedCmd) .command(cleanCmd) .command(createCmd) .command(diffCmd) .command(execCmd) .command(importCmd) .command(infoCmd) .command(initCmd) .command(linkCmd) .command(listCmd) .command(publishCmd) .command(runCmd) .command(versionCmd) .parse(argv, context); &#125; core/cli/index.js \"use strict\"; const dedent = require(\"dedent\"); const log = require(\"npmlog\"); const yargs = require(\"yargs/yargs\"); const globalOptions = require(\"@lerna/global-options\"); module.exports = lernaCLI; /** * A factory that returns a yargs() instance configured with everything except commands. * Chain .parse() from this method to invoke. * * @param &#123;Array = []&#125; argv * @param &#123;String = process.cwd()&#125; cwd */ function lernaCLI(argv, cwd) &#123; const cli = yargs(argv, cwd); return globalOptions(cli) .usage(\"Usage: $0 &lt;command> [options]\") .demandCommand(1, \"A command is required. Pass --help to see all available commands and options.\") .recommendCommands() .strict() .fail((msg, err) => &#123; // certain yargs validations throw strings :P const actual = err || new Error(msg); // ValidationErrors are already logged, as are package errors if (actual.name !== \"ValidationError\" &amp;&amp; !actual.pkg) &#123; // the recommendCommands() message is too terse if (/Did you mean/.test(actual.message)) &#123; log.error(\"lerna\", `Unknown command \"$&#123;cli.parsed.argv._[0]&#125;\"`); &#125; log.error(\"lerna\", actual.message); &#125; // exit non-zero so the CLI can be usefully chained cli.exit(actual.code > 0 ? actual.code : 1, actual); &#125;) .alias(\"h\", \"help\") .alias(\"v\", \"version\") .wrap(cli.terminalWidth()).epilogue(dedent` When a command fails, all logs are written to lerna-debug.log in the current working directory. For more information, find our manual at https://github.com/lerna/lerna `); &#125; core/global-options/index.js \"use strict\"; const os = require(\"os\"); module.exports = globalOptions; function globalOptions(yargs) &#123; // the global options applicable to _every_ command const opts = &#123; loglevel: &#123; defaultDescription: \"info\", describe: \"What level of logs to report.\", type: \"string\", &#125;, concurrency: &#123; defaultDescription: os.cpus().length, describe: \"How many processes to use when lerna parallelizes tasks.\", type: \"number\", requiresArg: true, &#125;, \"reject-cycles\": &#123; describe: \"Fail if a cycle is detected among dependencies.\", type: \"boolean\", &#125;, \"no-progress\": &#123; describe: \"Disable progress bars. (Always off in CI)\", type: \"boolean\", &#125;, progress: &#123; // proxy for --no-progress hidden: true, type: \"boolean\", &#125;, \"no-sort\": &#123; describe: \"Do not sort packages topologically (dependencies before dependents).\", type: \"boolean\", &#125;, sort: &#123; // proxy for --no-sort hidden: true, type: \"boolean\", &#125;, \"max-buffer\": &#123; describe: \"Set max-buffer (in bytes) for subcommand execution\", type: \"number\", requiresArg: true, &#125;, &#125;; // group options under \"Global Options:\" // 全局options归类为 Global Options: const globalKeys = Object.keys(opts).concat([\"help\", \"version\"]); return yargs .options(opts) .group(globalKeys, \"Global Options:\") .option(\"ci\", &#123; hidden: true, type: \"boolean\", &#125;); &#125; lerna的commandlist命令 \"use strict\"; const filterable = require(\"@lerna/filter-options\"); const listable = require(\"@lerna/listable\"); /** * @see https://github.com/yargs/yargs/blob/master/docs/advanced.md#providing-a-command-module */ exports.command = \"list\"; exports.aliases = [\"ls\", \"la\", \"ll\"]; exports.describe = \"List local packages\"; exports.builder = yargs => &#123; listable.options(yargs); return filterable(yargs); &#125;; exports.handler = function handler(argv) &#123; return require(\".\")(argv); &#125;; import-local在lerna的入口文件中，导入了import-local模块 在lerna开始执行时会先判断本地是否安装lerna，如果已经安装了，就导入本地安装的，否则就导入全局安装的lerna文件 #!/usr/bin/env node \"use strict\"; /* eslint-disable import/no-dynamic-require, global-require */ const importLocal = require(\"import-local\"); if (importLocal(__filename)) &#123; require(\"npmlog\").info(\"cli\", \"using local version of lerna\"); &#125; else &#123; require(\".\")(process.argv.slice(2)); &#125; import-local中的源码 'use strict'; const path = require('path'); const resolveCwd = require('resolve-cwd'); const pkgDir = require('pkg-dir'); module.exports = filename => &#123; const globalDir = pkgDir.sync(path.dirname(filename)); const relativePath = path.relative(globalDir, filename); const pkg = require(path.join(globalDir, 'package.json')); const localFile = resolveCwd.silent(path.join(pkg.name, relativePath)); // Use `path.relative()` to detect local package installation, // because __filename's case is inconsistent on Windows // Can use `===` when targeting Node.js 8 // See https://github.com/nodejs/node/issues/6624 return localFile &amp;&amp; path.relative(localFile, filename) !== '' ? require(localFile) : null; &#125;;","categories":[{"name":"脚手架","slug":"脚手架","permalink":"https://shibin-cli.github.io/blog/categories/%E8%84%9A%E6%89%8B%E6%9E%B6/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://shibin-cli.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"脚手架","slug":"scaffolding","date":"2021-01-10T00:00:00.000Z","updated":"2021-07-22T02:06:46.989Z","comments":true,"path":"2021/01/10/scaffolding/","link":"","permalink":"https://shibin-cli.github.io/blog/2021/01/10/scaffolding/","excerpt":"","text":"脚手架的本质作用创建项目的基础解构、提供项目规范和约定 相同的组织结构 相同的开发方式 相同的模块依赖 相同的工具配置 相同的基础代码 常用的脚手架工具 根据信息创建对应的项目基础结构（create-app、vue-cli） Yeoman Plop(例如创建一个组件、模块所需的文件)Yeoman安装yeomannpm install yo -g 安装generator# 安装对应的generator npm install generator-node -g # 运行脚手架 yo node # 创建cli文件 yo node:cli 自定义generator Yeoman的Generator模块名称必须是generator-&lt;name&gt; 首先创建对应的项目结构 npm install yeoman-generator generators/app.js const Generator = require('yeoman-generator') /** * 此文件为Generator的入口文件 * 需要导出一个继承自yeoman-generator的类型 * 在工作时会自动调用我们在此声明的一些生命周期方法 */ module.exports = class extends Generator &#123; //生成文件时会调用此方法 wriging() &#123; this.fs.write( this.destinationPath('test.txt'), Math.random().toString() ) &#125; &#125; 然后执行 npm link yo &lt;name> 创建模板文件夹 generators/app/teplates，该文件夹用于存放模板文件，模板为ejs模板 const Generator = require('yeoman-generator') module.exports = class extends Generator &#123; wriging() &#123; // 对应模板文件夹下的index.html const tpl = this.templatePath('index.html') const ctx = &#123; title: 'Yeoman', content: 'Yeoman is great!' &#125; const output = this.destinationPath('index.html') this.fs.copyTpl(tpl, output, ctx) &#125; &#125; 接收用户输入 module.exports = class extends Generator &#123; // 用于接收用户输入 prompting() &#123; return this.prompt([&#123; type: 'input', name: 'title', message: 'Your title', default: this.appname &#125;, &#123; type: 'input', name: 'content', message: 'Your content', default: this.appname &#125;]).then(answers => &#123; console.log(answers) this.answers = answers &#125;) &#125; //生成文件时会调用此方法 wriging() &#123; // 对应模板文件夹下的index.html const tpl = this.templatePath('index.html') const ctx = this.answers const output = this.destinationPath('index.html') this.fs.copyTpl(tpl, output, ctx) &#125; &#125; Plop 将plop模块作为项目开发依赖安装 在项目根目录下创建一个plopfile.js文件,定义脚手架任务 编写用于生成特定类型文件的模板 通过Plop提供的CLI运行脚手架服务 npm install plop --save-dev plopfile.js module.exports = plop=>&#123; plop.setGenerator('component',&#123; description: 'create a component', prompts:[&#123; type:'input', name:'name', message:'Component name', default:'MyComponent' &#125;], actions:[&#123; type:'add', path:'src/components/&#123;&#123;name&#125;&#125;/&#123;&#123;name&#125;&#125;.js', templateFile:'templates/component.hbs' &#125;] &#125;) &#125; 脚手架的工作原理创建项目,在package.json文件中指定bin(指定cli的入口文件) &#123; \"bin\" :\"cli.js\" &#125; cli.js #! /usr/bin/env node // cli文件开头必须这样写 // 如果是Linux或macOS系统还需要修改此文件的读写权限为755，具体就是通过 chmod 755 cli.js 实现修改 const fs = require('fs') const inquirer = require('inquirer') const path = require('path') const ejs = require('ejs') inquirer.prompt([&#123; type: 'input', name: 'name', message: 'project name', required:true &#125;]).then(answers => &#123; if(!answers.name)&#123; console.log('cancel') return &#125; const tmpDir = path.join(__dirname, 'templates') const destDir = process.cwd() fs.readdir(tmpDir, (err, files) => &#123; if (err) console.log(err) files.forEach(file => &#123; ejs.renderFile(path.join(tmpDir, file), answers, (err, res) => &#123; if (err) console.log(err) fs.writeFileSync(path.join(destDir, file), res) &#125;) &#125;); &#125;) &#125;) 然后执行，就可以进行本地调试 npm link 取消本地链接 # 将当前项目从全局node_modules中删除 npm unlink # link存在取消当前项目链接 npm unlink your-lib # link不存在 rm -rf node_modules npm install -S your-lib 问题 为什么全局安装npm install -g @vue/cli后会添加命令为vue？ 全局安装@vue/cli发生了什么？ 执行vue命令发生了什么？为什么vue指向一个js文件，为什么我们可以直接通过vue命令去执行它？ npm install -g @vue/cli后，vue的安装目录下package.json下bin决定了vue的命令 &#123; \"bin\": &#123; \"vue\": \"bin/vue.js\" &#125; &#125; 在执行vue命令时就会执行上面bin/vue.js文件 js文件无法直接执行，但是在js代码开头加上#! /usr/bin/env node就可以直接执行js代码了。其中/usr/bin/env 指的就是环境变量，/usr/bin/env node就是在环境变量中查找node。其实就相当于执行了node xx.js命令 #! /usr/bin/env node xxx /usr/bin/env也可以替换为node的安装路径，但是这样做可能会导致在别人的电脑上无法运行，因为每个人node的安装路径可能会不一样 脚手架参数console.log(process.argv)","categories":[{"name":"前端","slug":"前端","permalink":"https://shibin-cli.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://shibin-cli.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"es6基础","slug":"es6+","date":"2021-01-01T00:00:00.000Z","updated":"2021-07-22T02:06:46.989Z","comments":true,"path":"2021/01/01/es6+/","link":"","permalink":"https://shibin-cli.github.io/blog/2021/01/01/es6+/","excerpt":"","text":"部分内容参考了《ECMAScript 6 入门》 ES2015块级作用域在es6之前，只有两种作用域 全局作用域 函数作用域 es6新增了块级作用域，可以使用let和const声明 letlet 可以用来声明变量，它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 if (true) &#123; var a = 100 &#125; console.log(a) //100 将变量a换成使用let或const声明后,就会报错 if (true) &#123; let a = 100 &#125; console.log(a) //ReferenceError: a is not defined 如果使用let，声明的变量仅在块级作用域内有效 var a = []; for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;; &#125; a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。 不存在变量提升var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。但let或const声明的变量不存在变量提升 // var 的情况 console.log(foo); // 输出undefined var foo = 2; // let 的情况 console.log(bar); // 报错ReferenceError let bar = 2; 暂时性死区var tmp = 123; if (true) &#123; tmp = 'abc'; // ReferenceError let tmp; &#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 // 报错 function func() &#123; let a = 10; var a = 1; &#125; // 报错 function func() &#123; let a = 10; let a = 1; &#125; constconst用来声明一个只读的常量。一旦声明，常量的值就不能改变。其他的跟let一样 const foo = &#123;&#125;; // 为 foo 添加一个属性，可以成功 foo.prop = 123; foo.prop // 123 // 将 foo 指向另一个对象，就会报错 foo = &#123;&#125;; // TypeError: \"foo\" is read-only 在开发环境允许的条件下，声明变量时不要使用var，能用const就使用const，不能用就使用let 变量解构赋值数组的解构let [a, b, c] = [1, 2, 3] console.log(a, b, c) // 1 2 3 let [, , d] = [1, 2, 3] console.log(d) // 3 let [, d] = [1] console.log(d) // undefined 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。如果匹配不成功，变量的值就是undefined 可以使用...来匹配剩余的元素 let [e, , ...f] = [1, 2, 3, 4, 5, 6] console.log(f) // [ 3, 4, 5, 6 ] 默认值 let [x, y = 'b'] = ['a']; // x='a', y='b' 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 对象的解构lconst obj = &#123; name: 'Shibin', age: '17' &#125; let &#123; name, age &#125; = obj console.log(name, age) //Shibin 17 // 如果变量名与属性名不一致，可以这样写 let &#123; name: MyName &#125; = obj console.log(MyName) // 默认值 let &#123; title: myTitle = 'Hello' &#125; = obj console.log(myTitle) //Hello 字符串模板字符串模板字符串中嵌入变量，需要将变量名写在${}之中。 const name = 'Shibin' const msg = `Hello,$&#123;name&#125;` console.log(msg) // Hello,Shibin 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。 console.log(`1 + 2 = $&#123;1 + 2&#125;`) // 1 + 2 = 3 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 带标签的模板字符串模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串 const name = 'Shibin' const age = '17' function myFunc(str, name, age) &#123; console.log(str) // [ 'My name is ', \". I'm \", ' years old' ] console.log(name, age) // Shibin 17 let old = age > 1 ? `$&#123;age&#125; years old` : `$&#123;age&#125; year old` return str[0] + name + str[1] + old &#125; let res = myFunc`My name is $&#123;name&#125;. I'm $&#123;age&#125;` console.log(res) // My name is Shibin. I'm 1 year old 字符串方法 includes 是否包含xxx字符串 startsWith 是否以xxx开头 endsWith 是否以xxx结尾let a = 'https//www.github.com' console.log(a.includes('github')) // true console.log(a.startsWith('https')) // true console.log(a.endsWith('com')) // true 参数默认值function log(x, y = 'World') &#123; console.log(x, y); &#125; log('Hello') // Hello World 通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。function f(x = 1, y) &#123; return [x, y]; &#125; f() // [1, undefined] f(2) // [2, undefined] f(, 1) // 报错 所以在使用开发过程中,一定要没有默认值的参数在前，有默认值的参数在后 可以使用…获取剩余的参数,也要放到最后再使用 function fn(a, ...b) &#123; console.log(b) // [ 2, 3, 4, 5 ] &#125; fn(1, 2, 3, 4, 5) 展开数组和对象let a = [1, 2, 3, 4] console.log([...a]) // [ 1, 2, 3, 4 ] let obj = &#123; name: 'Shibin', age: '17' &#125; console.log(&#123; ...obj, sex: 'boy' &#125;)//&#123; name: 'Shibin', age: '17', sex: 'boy' &#125; 箭头函数es6允许使用=&gt;定义函数 const fn = a => a // 等同于 const fn = a => &#123; return a &#125; 如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 let getTempItem = id => (&#123; id: id, name: \"Temp\" &#125;) // 报错 let getTempItem = id => &#123; id: id, name: \"Temp\" &#125; 箭头函数不会改变this的指向，即函数内部this指向和函数外面this的指向一样 对象对象字面量当变量名与对象的属性名一样时，可以直接省略调冒号+属性值，写成下面的样子 const bar = 'bar' const obj = &#123; foo: 123, bar, func()&#123; console.log(123) &#125; &#125; // 等价于 const obj = &#123; foo: 123, bar: bar, func: func()&#123; console.log(123) &#125; &#125; 在声明对象时，还可以使用 [计算属性值]: 属性值来声明动态的属性值 const obj = &#123; ['a' + 'b']: 'aabb' &#125; // 等价于 const obj = &#123; ab: 'aabb' &#125; Object.assignObject.assign 将多个对象中的属性（可枚举属性）复制到一个目标对象中，后面的属性会覆盖前面的对象 const obj1 = &#123; name: 'Shibin' &#125; const obj2 = &#123; age: 17, sex: 'boy' &#125; const target = Object.assign(obj1, obj2) console.log(target) // &#123; name: 'Shibin', age: 17, sex: 'boy' &#125; Object.is判断两个变量是否相等 console.log(Object.is(NaN, NaN)) //true ProxyProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截 const person = &#123; name: 'Shibin', age: 17 &#125; const personProxy = new Proxy(person, &#123; get(target, key) &#123; console.log(target, key) // &#123; name: 'Shibin', age: 17 &#125; name return target[key] &#125;, set(target, key, val) &#123; console.log(target, key, val) if(key === 'age' &amp;&amp; typeof val !== 'number')&#123; throw new Error('age must be number') &#125; target[key] = val // &#123; name: 'Shibin', age: 17 &#125; sex boy &#125; &#125;) console.log(personProxy.name) console.log(personProxy.age) personProxy.sex = 'boy' age.age = 'aa' //报错 Error: age must be number Proxy相对于Object.defineProperty的优势 可以监听对象的删除 更好的支持数组对象的监视const person = &#123; name: 'Shibin', age: 17 &#125; const personProxy = new Proxy(person, &#123; deleteProperty(target, key) &#123; console.log(target, key) // &#123; name: 'Shibin', age: 17 &#125; age &#125; &#125;) delete personProxy.age const arr = [1, 2, 3, 4, 5] const personArr = new Proxy(arr, &#123; set(target, key, val) &#123; console.log(target, key, val) target[key] = val // [ 1, 2, 3, 4, 5 ] 5 6 // [ 1, 2, 3, 4, 5, 6 ] length 6 return true &#125; &#125;) personArr.push(6) console.log(arr) Proxy是以非侵入的方式监管了对象的读写 其他属性参考 https://es6.ruanyifeng.com/#docs/proxy ReflectReflect成员方法就是Proxy处理对象的默认实现。Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。 let person = &#123; name: 'Shibin', age: 17 &#125; const personProxy = new Proxy(person, &#123; get(target, key, receiver) &#123; return Reflect.set(target, key, receiver) &#125;, set(target, key, val, receiver) &#123; return Reflect.set(target, key, val, receiver) &#125; &#125;) 它统一提供了一套用于操作对象的API 一共提供了13个静态方法 Reflect.apply(target, thisArg, args) Reflect.construct(target, args) Reflect.get(target, name, receiver) Reflect.set(target, name, value, receiver) Reflect.defineProperty(target, name, desc) Reflect.deleteProperty(target, name) Reflect.has(target, name) Reflect.ownKeys(target) R*eflect.isExtensible(target) Reflect.preventExtensions(target) Reflect.getOwnPropertyDescriptor(target, name) Reflect.getPrototypeOf(target) Reflect.setPrototypeOf(target, prototype) Classclass Person &#123; constructor(name) &#123; this.name = name &#125; say() &#123; console.log(`Hello,my name is $&#123;this.name&#125;`) &#125; &#125; const person = new Person('Tom') person.say() // Hello,my name is Tom 如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 class Foo &#123; static classMethod() &#123; return 'hello'; &#125; &#125; Foo.classMethod() // 'hello' var foo = new Foo(); foo.classMethod() Class的继承Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 class Person &#123; constructor(name) &#123; this.name = name &#125; say() &#123; console.log(`Hello,my name is $&#123;this.name&#125;`) &#125; &#125; class Student extends Person &#123; constructor(name, age) &#123; super(name) this.age = age &#125; sayAge() &#123; console.log(this.age) &#125; &#125; const student = new Student('Tom', 20) student.say() // Hello,my name is Tom student.sayAge() // 20 super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则新建实例时会报错 Set类似于数组，但是成员的值都是唯一的，没有重复的值。 const a = new Set() a.add(1).add(2).add(3).add(3) console.log(a) // Set(3) &#123; 1, 2, 3 &#125; Set的方法 Set.prototype.add(value)：添加某个值，返回 Set 结构本身。 Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。 Set.prototype.clear()：清除所有成员，没有返回值。 Set.prototype.size：返回Set实例的成员总数。 Set的遍历操作 Set.prototype.keys()：返回键名的遍历器 Set.prototype.values()：返回键值的遍历器 Set.prototype.entries()：返回键值对的遍历器 Set.prototype.forEach()：使用回调函数遍历每个成员 Set转换为数组 console.log(Array.from(a)) // [ 1, 2, 3 ] console.log([...a]) // [ 1, 2, 3 ] WeakSetWeakSet 结构与 Set 类似，也是不重复的值的集合.但是，它与 Set 有两个区别。 WeakSet 的成员只能是对象，而不能是其他类型的值。 WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用。也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。 这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。 这些特点同样适用于 WeakMap 结构。 Map它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。 const obj = &#123; name: 'tom' &#125; const a = new Map() a.set(obj, 100) console.log(a) // Map(1) &#123; &#123; name: 'tom' &#125; => 100 &#125; console.log(a.get(obj)) //100 // 清除set中的内容 a.clear() console.log(a) //Map(0) &#123;&#125; Map实例的属性方法 size 返回 Map 结构的成员总数。 Map.prototype.set(key, value) Map.prototype.get(key) Map.prototype.has(key) 表示某个键是否在当前 Map 对象之中 Map.prototype.delete(key) delete删除某个键，返回true。如果删除失败，返回false。 Map.prototype.clear() 清除所有成员 Symbol一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object） let a = Symbol('123') let b = Symbol('123') console.log(a === b) //false let obj = &#123;&#125; obj[a] = 200 obj[b] = 100 console.log(obj) // &#123; [Symbol(123)]: 200, [Symbol(123)]: 100 &#125; 对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。 有时，我们希望重新使用同一个 Symbol 值,可以使用Symbol.for() let s1 = Symbol.for('foo'); let s2 = Symbol.for('foo'); console.log(s1 === s2) // true Object.keys和for in循环无法获取到属性名为symbol的属性，可以使用getOwnPropertySymbols获取到属性名为symbol的属性 IteratorIterator 的作用有三个： 为各种数据结构，提供一个统一的、简便的访问接口 使得数据结构的成员能够按某种次序排列 ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费 Iterator 的遍历过程是这样的 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员 不断调用指针对象的next方法，直到它指向数据结构的结束位置 每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。 // 实现Iterator 接口 const obj = &#123; [Symbol.iterator] : function () &#123; return &#123; next: function () &#123; return &#123; value: 1, done: true &#125;; &#125; &#125;; &#125; &#125; ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的” 原生具备 Iterator 接口的数据结构如下 Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定 for…of作为遍历所有数据结构的统一的方法。 const arr = [100, 200, 300, 400, 900] for (const item of arr) &#123; console.log(item) &#125; // 输出 // 100 // 200 // 300 // 400 // 900 let s = new Set(arr) for (const item of s) &#123; console.log(item) &#125; // 输出 // 100 // 200 // 300 // 400 // 900 let m = new Map() m.set('name','tom') m.set('age',20) for (const item of m) &#123; console.log(item) &#125; // 输出 // [ 'name', 'tom' ] // [ 'age', 20 ] 生成器在function关键字与函数名加上一个星号就是生成器函数，函数体内部可以使用yied表达式 function* foo() &#123; console.log('foo') return 'foo' &#125; let res = foo() console.log(res.next()) //&#123; value: 'foo', done: true &#125; function* foo() &#123; console.log('foo') yield '1' yield '2' return 'foo' &#125; let res = foo() console.log(res.next()) //&#123; value: '1', done: false &#125; console.log(res.next()) //&#123; value: '2', done: false &#125; Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。 遍历器对象的next方法的运行逻辑如下。 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 如果该函数没有return语句，则返回的对象的value属性值为undefined。 yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。 /* next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。 */ function* f() &#123; for(var i = 0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125; &#125; var g = f(); g.next() // &#123; value: 0, done: false &#125; g.next() // &#123; value: 1, done: false &#125; g.next(true) // &#123; value: 0, done: false &#125; ES2016Array.prototype.inclodes[1, 2, 3].includes(2) // true [1, 2, 3].includes(4) // false [1, 2, NaN].includes(NaN) // true 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度 indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。 指数运算符// es5 console.log(Math.pow(2, 4)) // es2016 console.log(2 ** 4) ES2017bject.values()返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。 const obj = &#123; foo: 'bar', baz: 42 &#125; console.log(Object.values(obj)) // [ 'bar', 42 ] Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。 const obj = &#123; foo: 'bar', baz: 42 &#125; Object.entries(obj) // [ [\"foo\", \"bar\"], [\"baz\", 42] ] 如果原对象的属性名是一个 Symbol 值，该属性会被忽略。 console.log(Object.entries(&#123; [Symbol()]: 123, foo: 'abc' &#125;)) // [ [ 'foo', 'abc' ] ] Object.entries的基本用途是遍历对象的属性。 const obj = &#123; foo: 'bar', baz: 42 &#125; for (const [k, v] of Object.entries(obj)) &#123; console.log(k, v) &#125; // foo bar // baz 42 Object.getOwnPropertyDescriptors返回指定对象所有自身属性（非继承属性）的描述对象。 const f1 = &#123; name: 'Shibin', age: 10, get say() &#123; return this.name + ':' + this.age &#125; &#125; const f2 = Object.assign(&#123;&#125;, f1) f2.age = 17 console.log(f2.say) //&#123; name: 'Shibin', age: 17, say: 'Shibin:10' &#125; const descriptors = Object.getOwnPropertyDescriptors(f1) const f3 = Object.defineProperties(&#123;&#125;, descriptors) f3.age = 18 console.log(f3.say) //Shibin:18 String.prototype.padEnd String.prototype.padStart字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 const str='123' console.log(str.padEnd(8, '0')) // 12300000 console.log(str.padStart(8, '0')) // 00000123 伪逗号// 函数参数末尾添加伪逗号 function fn1(a, b,) &#123; &#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://shibin-cli.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://shibin-cli.github.io/blog/tags/JavaScript/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://shibin-cli.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发工具","slug":"开发工具","permalink":"https://shibin-cli.github.io/blog/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"脚手架","slug":"脚手架","permalink":"https://shibin-cli.github.io/blog/categories/%E8%84%9A%E6%89%8B%E6%9E%B6/"}],"tags":[{"name":"模块化开发","slug":"模块化开发","permalink":"https://shibin-cli.github.io/blog/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://shibin-cli.github.io/blog/tags/JavaScript/"},{"name":"微前端","slug":"微前端","permalink":"https://shibin-cli.github.io/blog/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"name":"工具","slug":"工具","permalink":"https://shibin-cli.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"性能","slug":"性能","permalink":"https://shibin-cli.github.io/blog/tags/%E6%80%A7%E8%83%BD/"}]}