{"meta":{"title":"web学习笔记","subtitle":"web学习笔记","description":"学习笔记","author":"Shibin You","url":"https://shibin-cli.github.io/blog","root":"/blog/"},"pages":[],"posts":[{"title":"jsdoc","slug":"jsdoc","date":"2021-06-29T14:36:34.151Z","updated":"2021-06-29T14:36:34.151Z","comments":true,"path":"2021/06/29/jsdoc/","link":"","permalink":"https://shibin-cli.github.io/blog/2021/06/29/jsdoc/","excerpt":"","text":"类型注释 https://jsdoc.app/ 12345678910/** * @param &#123;number&#125; a param1 * @param &#123;number&#125; b param2 * @returns &#123;number&#125; * */function fn(a, b) &#123; return a + b&#125;let a = fn() 常见的类型注释 @type 变量类型 @param(或@params或@argument) 参数类型 returns(或returns) 返回值类型 typedef 相当于ts中的type Status = &quot;open&quot; | &quot;close&quot; @callback 回调函数 https://jsdoc.app/tags-callback.html @template @class（@constructor） @this 函数内部this指向 @extends(@arguments) enum 1234/**@typedef &#123;&#x27;open&#x27;|&#x27;close&#x27;&#125; Status *//**@type &#123;Status&#125; */const a = &#x27;close&#x27; 在webpack中使用 1234/** @type &#123;import(&#x27;webpack&#x27;).Configuration&#125; */module.exports = &#123; ...&#125;","categories":[],"tags":[]},{"title":"Lerna","slug":"lerna","date":"2021-06-29T14:36:34.151Z","updated":"2021-06-29T14:36:34.151Z","comments":true,"path":"2021/06/29/lerna/","link":"","permalink":"https://shibin-cli.github.io/blog/2021/06/29/lerna/","excerpt":"","text":"Lerna 是一个优化基于git+npm的多package项目管理工具 优势 大幅度减少重复操作 提升操作单标椎化 原生脚手架的痛点 重复操作，多个package 本地link 依赖安装 单元测试 代码提交 代码发布 版本一致性 版本一致性 发布后相互依赖版本升级 package越多，管理复杂度就越高 Lerna的使用12345678910111213141516171819npm install lerna -g# 初始化lernalerna init# 创建一个包lerna create core# 安装依赖lerna add xxx# 删除依赖lerna clean# 给指定package安装依赖lerna add vue packages/core# 重新安装依赖lerna bootstrap# 本地项目相互依赖lerna link# 执行npm scriptlerna run# 发布lerna publish lerna源码首先从github上下载源码 https://github.com/lerna/lerna 然后安装依赖 1npm install 如果无法安装成功可以修改.npmrc文件，修改镜像地址为淘宝镜像 https://registry.npm.taobao.org/ 12# just in case a private registry is configured in ~&#x2F;.npmrcregistry &#x3D; https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F; 通过查看package.json文件可以看出入口文件为core/lerna/cli.js 1234567&#123; ... &quot;bin&quot;: &#123; &quot;lerna&quot;: &quot;core/lerna/cli.js&quot; &#125;, ...&#125; 在core/lerna/cli.js中引入了core/lerna/cli.js 123456789101112#!/usr/bin/env node&quot;use strict&quot;;/* eslint-disable import/no-dynamic-require, global-require */const importLocal = require(&quot;import-local&quot;);if (importLocal(__filename)) &#123; require(&quot;npmlog&quot;).info(&quot;cli&quot;, &quot;using local version of lerna&quot;);&#125; else &#123; require(&quot;.&quot;)(process.argv.slice(2));&#125; 我们可以看到很多模块导入时通过@lerna/xxx导入的 1const cli = require(&quot;@lerna/cli&quot;); 它导入的并不是外面npm安装的模块，我们可以查看当前目录下的package.json文件,在这里配置了模块的路径为本地路径，当模块发布时,我们也不必担心，lerna会自动处理模块的导入 12345678910&#123; ... &quot;dependencies&quot;: &#123; &quot;@lerna/add&quot;: &quot;file:../../commands/add&quot;, &quot;@lerna/bootstrap&quot;: &quot;file:../../commands/bootstrap&quot;, &quot;@lerna/changed&quot;: &quot;file:../../commands/changed&quot;, &quot;@lerna/clean&quot;: &quot;file:../../commands/clean&quot;, ... &#125; &#125; yargslerna中使用了yargs这个模块，所以首先要了解yargs如何使用 实现一个yargs最简单的脚手架1234567#! /usr/bin/env nodeconst yargs = require(&#x27;yargs&#x27;)// 同事还会将掺入的参数解析成对象yargs(process.argv.slice(2)).argv// 后者可以写成 // yargs().parse(process.argv.slice(2)) 然后输入 1cli --help 就会出现 123选项： --help 显示帮助信息 [布尔] --version 显示版本号 [布尔] yargs常用的方法对应方法的文档可以查看 https://github.com/yargs/yargs/blob/master/docs/api.md 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const argv = process.argv.slice(2)const cli = yargs()const constext = &#123; cliVersion: pkg.version&#125;cli.usage(&#x27;cli-test [command] &lt;options&gt;&#x27;) .alias(&#x27;v&#x27;, &#x27;version&#x27;) //别名 .alias(&#x27;h&#x27;, &#x27;help&#x27;) // 定义用户输出的最小长度和最大长度 // https://github.com/yargs/yargs/blob/master/docs/api.md#demandCommand .demandCommand(1, &#x27;A command is required&#x27;) .wrap(cli.terminalWidth()) // 控制台最后输出的内容 .epilogue(dedent` das aa asd`) // 命令 .command(&#x27;init [name]&#x27;, &#x27;Do it in a project&#x27;, yargs =&gt; &#123; yargs .option(&#x27;name&#x27;, &#123; type: &#x27;string&#x27;, describe: &#x27;Name of a project&#x27; &#125;) &#125;, argv =&gt; &#123; console.log(argv) &#125;) .recommendCommands() .fail((err) =&gt; &#123; console.log(err) &#125;) .command(&#123; command: &#x27;list&#x27;, aliases: [&#x27;ls&#x27;, &#x27;la&#x27;, &#x27;ll&#x27;], builder: yargs =&gt; &#123; console.log(yargs) return &#123;&#125; &#125;, handler: argv =&gt; &#123; console.log(argv) &#125; &#125;) .options(&#123; debug: &#123; type: &#x27;boolean&#x27;, describe: &#x27;Boostrap debug mode&#x27;, alias: &#x27;d&#x27; &#125; &#125;) // 选项 如vue create a -r=https://registry.npm.taobao.org/ .option(&#x27;registry&#x27;, &#123; type: &#x27;string&#x27;, describe: &#x27;Define global registry&#x27;, alias: &#x27;r&#x27; &#125;) //命令在控制台的分类 .group([&#x27;debug&#x27;], &#x27;Dev Options&#x27;) .strict() // constext会和argv进行合并 .parse(argv, constext) lerna的初始化过程lerna的入口文件core/lerna/cli.js 12345678910111213#!/usr/bin/env node&quot;use strict&quot;;/* eslint-disable import/no-dynamic-require, global-require */const importLocal = require(&quot;import-local&quot;);if (importLocal(__filename)) &#123; require(&quot;npmlog&quot;).info(&quot;cli&quot;, &quot;using local version of lerna&quot;);&#125; else &#123; // 引入的当前目录下的index.js require(&quot;.&quot;)(process.argv.slice(2));&#125; core/lerna/index.js，该文件中主要是注册了一些命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&quot;use strict&quot;;const cli = require(&quot;@lerna/cli&quot;);const addCmd = require(&quot;@lerna/add/command&quot;);const bootstrapCmd = require(&quot;@lerna/bootstrap/command&quot;);const changedCmd = require(&quot;@lerna/changed/command&quot;);const cleanCmd = require(&quot;@lerna/clean/command&quot;);const createCmd = require(&quot;@lerna/create/command&quot;);const diffCmd = require(&quot;@lerna/diff/command&quot;);const execCmd = require(&quot;@lerna/exec/command&quot;);const importCmd = require(&quot;@lerna/import/command&quot;);const infoCmd = require(&quot;@lerna/info/command&quot;);const initCmd = require(&quot;@lerna/init/command&quot;);const linkCmd = require(&quot;@lerna/link/command&quot;);const listCmd = require(&quot;@lerna/list/command&quot;);const publishCmd = require(&quot;@lerna/publish/command&quot;);const runCmd = require(&quot;@lerna/run/command&quot;);const versionCmd = require(&quot;@lerna/version/command&quot;);const pkg = require(&quot;./package.json&quot;);module.exports = main;function main(argv) &#123; const context = &#123; lernaVersion: pkg.version, &#125;; return cli() .command(addCmd) .command(bootstrapCmd) .command(changedCmd) .command(cleanCmd) .command(createCmd) .command(diffCmd) .command(execCmd) .command(importCmd) .command(infoCmd) .command(initCmd) .command(linkCmd) .command(listCmd) .command(publishCmd) .command(runCmd) .command(versionCmd) .parse(argv, context);&#125; core/cli/index.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&quot;use strict&quot;;const dedent = require(&quot;dedent&quot;);const log = require(&quot;npmlog&quot;);const yargs = require(&quot;yargs/yargs&quot;);const globalOptions = require(&quot;@lerna/global-options&quot;);module.exports = lernaCLI;/** * A factory that returns a yargs() instance configured with everything except commands. * Chain .parse() from this method to invoke. * * @param &#123;Array = []&#125; argv * @param &#123;String = process.cwd()&#125; cwd */function lernaCLI(argv, cwd) &#123; const cli = yargs(argv, cwd); return globalOptions(cli) .usage(&quot;Usage: $0 &lt;command&gt; [options]&quot;) .demandCommand(1, &quot;A command is required. Pass --help to see all available commands and options.&quot;) .recommendCommands() .strict() .fail((msg, err) =&gt; &#123; // certain yargs validations throw strings :P const actual = err || new Error(msg); // ValidationErrors are already logged, as are package errors if (actual.name !== &quot;ValidationError&quot; &amp;&amp; !actual.pkg) &#123; // the recommendCommands() message is too terse if (/Did you mean/.test(actual.message)) &#123; log.error(&quot;lerna&quot;, `Unknown command &quot;$&#123;cli.parsed.argv._[0]&#125;&quot;`); &#125; log.error(&quot;lerna&quot;, actual.message); &#125; // exit non-zero so the CLI can be usefully chained cli.exit(actual.code &gt; 0 ? actual.code : 1, actual); &#125;) .alias(&quot;h&quot;, &quot;help&quot;) .alias(&quot;v&quot;, &quot;version&quot;) .wrap(cli.terminalWidth()).epilogue(dedent` When a command fails, all logs are written to lerna-debug.log in the current working directory. For more information, find our manual at https://github.com/lerna/lerna `);&#125; core/global-options/index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&quot;use strict&quot;;const os = require(&quot;os&quot;);module.exports = globalOptions;function globalOptions(yargs) &#123; // the global options applicable to _every_ command const opts = &#123; loglevel: &#123; defaultDescription: &quot;info&quot;, describe: &quot;What level of logs to report.&quot;, type: &quot;string&quot;, &#125;, concurrency: &#123; defaultDescription: os.cpus().length, describe: &quot;How many processes to use when lerna parallelizes tasks.&quot;, type: &quot;number&quot;, requiresArg: true, &#125;, &quot;reject-cycles&quot;: &#123; describe: &quot;Fail if a cycle is detected among dependencies.&quot;, type: &quot;boolean&quot;, &#125;, &quot;no-progress&quot;: &#123; describe: &quot;Disable progress bars. (Always off in CI)&quot;, type: &quot;boolean&quot;, &#125;, progress: &#123; // proxy for --no-progress hidden: true, type: &quot;boolean&quot;, &#125;, &quot;no-sort&quot;: &#123; describe: &quot;Do not sort packages topologically (dependencies before dependents).&quot;, type: &quot;boolean&quot;, &#125;, sort: &#123; // proxy for --no-sort hidden: true, type: &quot;boolean&quot;, &#125;, &quot;max-buffer&quot;: &#123; describe: &quot;Set max-buffer (in bytes) for subcommand execution&quot;, type: &quot;number&quot;, requiresArg: true, &#125;, &#125;; // group options under &quot;Global Options:&quot; // 全局options归类为 Global Options: const globalKeys = Object.keys(opts).concat([&quot;help&quot;, &quot;version&quot;]); return yargs .options(opts) .group(globalKeys, &quot;Global Options:&quot;) .option(&quot;ci&quot;, &#123; hidden: true, type: &quot;boolean&quot;, &#125;);&#125; lerna的commandlist命令 123456789101112131415161718192021222324&quot;use strict&quot;;const filterable = require(&quot;@lerna/filter-options&quot;);const listable = require(&quot;@lerna/listable&quot;);/** * @see https://github.com/yargs/yargs/blob/master/docs/advanced.md#providing-a-command-module */exports.command = &quot;list&quot;;exports.aliases = [&quot;ls&quot;, &quot;la&quot;, &quot;ll&quot;];exports.describe = &quot;List local packages&quot;;exports.builder = yargs =&gt; &#123; listable.options(yargs); return filterable(yargs);&#125;;exports.handler = function handler(argv) &#123; return require(&quot;.&quot;)(argv);&#125;; import-local在lerna的入口文件中，导入了import-local模块 在lerna开始执行时会先判断本地是否安装lerna，如果已经安装了，就导入本地安装的，否则就导入全局安装的lerna文件 123456789101112#!/usr/bin/env node&quot;use strict&quot;;/* eslint-disable import/no-dynamic-require, global-require */const importLocal = require(&quot;import-local&quot;);if (importLocal(__filename)) &#123; require(&quot;npmlog&quot;).info(&quot;cli&quot;, &quot;using local version of lerna&quot;);&#125; else &#123; require(&quot;.&quot;)(process.argv.slice(2));&#125; import-local中的源码 1234567891011121314151617&#x27;use strict&#x27;;const path = require(&#x27;path&#x27;);const resolveCwd = require(&#x27;resolve-cwd&#x27;);const pkgDir = require(&#x27;pkg-dir&#x27;);module.exports = filename =&gt; &#123; const globalDir = pkgDir.sync(path.dirname(filename)); const relativePath = path.relative(globalDir, filename); const pkg = require(path.join(globalDir, &#x27;package.json&#x27;)); const localFile = resolveCwd.silent(path.join(pkg.name, relativePath)); // Use `path.relative()` to detect local package installation, // because __filename&#x27;s case is inconsistent on Windows // Can use `===` when targeting Node.js 8 // See https://github.com/nodejs/node/issues/6624 return localFile &amp;&amp; path.relative(localFile, filename) !== &#x27;&#x27; ? require(localFile) : null;&#125;;","categories":[],"tags":[]},{"title":"JavaScript性能优化","slug":"performance","date":"2021-06-29T14:36:34.151Z","updated":"2021-06-29T14:36:34.151Z","comments":true,"path":"2021/06/29/performance/","link":"","permalink":"https://shibin-cli.github.io/blog/2021/06/29/performance/","excerpt":"","text":"内存管理为什么需要使用内存管理 内存管理介绍内存: 有可读写单元组成，表示一片可操作空间 管理：人为的去操作一片空间的申请、使用和释放 内存管理：开发者主动申请空间、使用空间、释放空间 管理流程： 申请 -&gt; 管理 -&gt; 释放 123456// 申请let obj = &#123;&#125;// 使用obj.name = &#x27;aa&#x27;// 释放obj = null Javascript中的垃圾回收 JavaScript中内存管理是自动的 对象在不被引用时时垃圾、对象不能从根上访问到时时垃圾 JavaScript中的可达对象 可以访问到的对象就是可达对象（引用、作用域链） 可达的标准就是从根出发是否能够被找到 JavaScript中的根就可以理解为时全局变量对象 JavaScript中的引用与可达 12345let obj = &#123; name: &#x27;JavaScript&#x27;&#125;let obj2 = objobj = null 上面代码中obj虽然obj赋值为null，但是obj2还在引用obj对象，所以obj依然是可达的 GC算法 GC就是垃圾回收机制的简写 GC可以找到内存中的垃圾、并释放和回收空间 GC中的垃圾是什么 程序中不在需要使用的对象 程序中不能再访问到的对象 GC算法是什么 GC算法是一种机制，垃圾回收器完成具体的工作 工作的内容就是查找垃圾释放空间、回收空间 算法是工作时查找和回收所遵循的规则 常见的GC算法 引用计数 标记清除 标记整理 分代回收 引用计数 引用计数的核心就是设置引用数，判断当前引用计数是否位0 引用关系发生改变时修改引用数字 引用数字为0时，立即回收 引用计数的优点 发现垃圾时立即回收 最大限度的减少程序的暂停 引用计数的缺点 无法回收循环引用的对象 资源开销大 下面代码就会引起循环引用 1234567function fn() &#123; const obj1 = &#123;&#125; const obj2 = &#123;&#125; obj1.name = obj2 obj2.name = obj1&#125;fn() 标记清除分标记和清除两个阶段完成 遍历所有对象找标记活动对象（查询所有的可达对象进行标记） 遍历所有对象清除没有标记的对象 回收相应的空间 标记清除的优点 可以解决前面提到的对象引用的问题 标记清除的缺点 空间的碎片化 不能立即回收对象标记整理 标记整理可以看做时标记清除的增强 标记阶段的操作和标记清除一致 清除阶段会先执行整理，移动对象位置 优点 减少空间碎片化 不能立即回收对象V8 V8是一款主流的JavaScript执行引擎 采用即时编译 V8内存设限 V8垃圾回收策略采用分代回收，内存分为新生代和老生代，针对不同对象采用不同的算法 新生代对象采用GC算法 V8常用的GC算法 分代回收 空间复制 标记清除 标记整理 标记增量V8内存分配 V8内存空间一分为二 小空间用于存储新生代对象（32M | 16M）,新生代指的是存活时间较短的对象 新生代对象回收实现 回收过程采用复制算法+标记整理 新生代存储分为两个等大小空间 使用空间为from,空闲空间为to 活动对象存储与from空间，标记整理后活动对象拷贝至To from与to交换空间完成释放 回收过程细节说明 拷贝过程中会出现晋升，晋升就是将新生代对象移动至老生代 一轮GC还存活的的新生代需要晋升 To空间的使用率超过25%需要晋升 老生代对象回收老生代对象指的就是存活时间较长的对象 老生代对象限制：64位操作系统1.4G、32位操作系统700M 回收 只要采用标记清除、标记整理、标记增量算法 首先采用标记清除完成垃圾回收空间的清除 采用标记整理进行空间优化（晋升时触发） 采用增量标记进行效率优化 程序触发垃圾回收后，会遍历对象进行标记，之后标记和程序执行交替进行（将标记操作分成了多步，程序停顿的时间拆分成了多个小段），标记操作完成后，完成清除，程序继续执行 新生代与老生代回收对比 新生代区域垃圾回收使用空间交换时间 老生代区域垃圾回收不适合复制算法 PerformanceGC的目的是为了实现内存空间的良性循环，Performance提供多种监控方式 打开浏览器控制台，选择Performance，开启录制功能 内存问题的外在表现 页面出现延迟加载或经常性暂停 页面出现出现持续糟糕的性能 页面的性能随着时间延长越来越差 监控内存的几种方式界定内存问题的标准 内存泄漏：内存使用持续升高 内存膨胀：在多数设备上都存在性能问题 频繁的垃圾回收：通过内存变化图进行分析 内存监控的几种方式 浏览器的任务管理器（shift + esc） Timeline时序图记录 堆快照查找分离DOM（浏览器控制台&gt;内存） 频繁的垃圾回收 timtLine中频繁的上升或下降 任务管理器数据频繁的增加减少 代码优化可通过 https://jsperf.com/ 对代码进行性能测试 慎用全局变量为什么要慎用 全局变量定义在全局执行上下文，是所有作用域链的顶端 全局执行上下文一直存在于上下文执行栈，直到程序退出 如果某个局部作用域出现了同名变量则会遮蔽或污染全局","categories":[],"tags":[]},{"title":"脚手架","slug":"scaffolding","date":"2021-06-29T14:36:34.151Z","updated":"2021-06-29T14:36:34.151Z","comments":true,"path":"2021/06/29/scaffolding/","link":"","permalink":"https://shibin-cli.github.io/blog/2021/06/29/scaffolding/","excerpt":"","text":"脚手架的本质作用创建项目的基础解构、提供项目规范和约定 相同的组织结构 相同的开发方式 相同的模块依赖 相同的工具配置 相同的基础代码 常用的脚手架工具 根据信息创建对应的项目基础结构（create-app、vue-cli） Yeoman Plop(例如创建一个组件、模块所需的文件)Yeoman安装yeoman1npm install yo -g 安装generator123456# 安装对应的generatornpm install generator-node -g# 运行脚手架yo node# 创建cli文件yo node:cli 自定义generator Yeoman的Generator模块名称必须是generator-&lt;name&gt; 首先创建对应的项目结构 1npm install yeoman-generator generators/app.js 123456789101112131415const Generator = require(&#x27;yeoman-generator&#x27;)/** * 此文件为Generator的入口文件 * 需要导出一个继承自yeoman-generator的类型 * 在工作时会自动调用我们在此声明的一些生命周期方法 */module.exports = class extends Generator &#123; //生成文件时会调用此方法 wriging() &#123; this.fs.write( this.destinationPath(&#x27;test.txt&#x27;), Math.random().toString() ) &#125;&#125; 然后执行 12npm linkyo &lt;name&gt; 创建模板文件夹 generators/app/teplates，该文件夹用于存放模板文件，模板为ejs模板 1234567891011const Generator = require(&#x27;yeoman-generator&#x27;)module.exports = class extends Generator &#123; wriging() &#123; // 对应模板文件夹下的index.html const tpl = this.templatePath(&#x27;index.html&#x27;) const ctx = &#123; title: &#x27;Yeoman&#x27;, content: &#x27;Yeoman is great!&#x27; &#125; const output = this.destinationPath(&#x27;index.html&#x27;) this.fs.copyTpl(tpl, output, ctx) &#125;&#125; 接收用户输入 123456789101112131415161718192021222324252627module.exports = class extends Generator &#123; // 用于接收用户输入 prompting() &#123; return this.prompt([&#123; type: &#x27;input&#x27;, name: &#x27;title&#x27;, message: &#x27;Your title&#x27;, default: this.appname &#125;, &#123; type: &#x27;input&#x27;, name: &#x27;content&#x27;, message: &#x27;Your content&#x27;, default: this.appname &#125;]).then(answers =&gt; &#123; console.log(answers) this.answers = answers &#125;) &#125; //生成文件时会调用此方法 wriging() &#123; // 对应模板文件夹下的index.html const tpl = this.templatePath(&#x27;index.html&#x27;) const ctx = this.answers const output = this.destinationPath(&#x27;index.html&#x27;) this.fs.copyTpl(tpl, output, ctx) &#125;&#125; Plop 将plop模块作为项目开发依赖安装 在项目根目录下创建一个plopfile.js文件,定义脚手架任务 编写用于生成特定类型文件的模板 通过Plop提供的CLI运行脚手架服务 1npm install plop --save-dev plopfile.js 12345678910111213141516module.exports = plop=&gt;&#123; plop.setGenerator(&#x27;component&#x27;,&#123; description: &#x27;create a component&#x27;, prompts:[&#123; type:&#x27;input&#x27;, name:&#x27;name&#x27;, message:&#x27;Component name&#x27;, default:&#x27;MyComponent&#x27; &#125;], actions:[&#123; type:&#x27;add&#x27;, path:&#x27;src/components/&#123;&#123;name&#125;&#125;/&#123;&#123;name&#125;&#125;.js&#x27;, templateFile:&#x27;templates/component.hbs&#x27; &#125;] &#125;)&#125; 脚手架的工作原理创建项目,在package.json文件中指定bin(指定cli的入口文件) 123&#123; &quot;bin&quot; :&quot;cli.js&quot;&#125; cli.js 123456789101112131415161718192021222324252627282930#! /usr/bin/env node// cli文件开头必须这样写// 如果是Linux或macOS系统还需要修改此文件的读写权限为755，具体就是通过 chmod 755 cli.js 实现修改const fs = require(&#x27;fs&#x27;)const inquirer = require(&#x27;inquirer&#x27;)const path = require(&#x27;path&#x27;)const ejs = require(&#x27;ejs&#x27;)inquirer.prompt([&#123; type: &#x27;input&#x27;, name: &#x27;name&#x27;, message: &#x27;project name&#x27;, required:true&#125;]).then(answers =&gt; &#123; if(!answers.name)&#123; console.log(&#x27;cancel&#x27;) return &#125; const tmpDir = path.join(__dirname, &#x27;templates&#x27;) const destDir = process.cwd() fs.readdir(tmpDir, (err, files) =&gt; &#123; if (err) console.log(err) files.forEach(file =&gt; &#123; ejs.renderFile(path.join(tmpDir, file), answers, (err, res) =&gt; &#123; if (err) console.log(err) fs.writeFileSync(path.join(destDir, file), res) &#125;) &#125;); &#125;)&#125;) 然后执行，就可以进行本地调试 1npm link 取消本地链接 1234567# 将当前项目从全局node_modules中删除npm unlink# link存在取消当前项目链接npm unlink your-lib# link不存在rm -rf node_modulesnpm install -S your-lib 问题 为什么全局安装npm install -g @vue/cli后会添加命令为vue？ 全局安装@vue/cli发生了什么？ 执行vue命令发生了什么？为什么vue指向一个js文件，为什么我们可以直接通过vue命令去执行它？ npm install -g @vue/cli后，vue的安装目录下package.json下bin决定了vue的命令 12345&#123; &quot;bin&quot;: &#123; &quot;vue&quot;: &quot;bin/vue.js&quot; &#125;&#125; 在执行vue命令时就会执行上面bin/vue.js文件 js文件无法直接执行，但是在js代码开头加上#! /usr/bin/env node就可以直接执行js代码了。其中/usr/bin/env 指的就是环境变量，/usr/bin/env node就是在环境变量中查找node。其实就相当于执行了node xx.js命令 12#! /usr/bin/env nodexxx /usr/bin/env也可以替换为node的安装路径，但是这样做可能会导致在别人的电脑上无法运行，因为每个人node的安装路径可能会不一样 脚手架参数1console.log(process.argv)","categories":[],"tags":[]},{"title":"前段常用工具","slug":"tools","date":"2021-06-29T14:36:34.151Z","updated":"2021-06-29T14:36:34.151Z","comments":true,"path":"2021/06/29/tools/","link":"","permalink":"https://shibin-cli.github.io/blog/2021/06/29/tools/","excerpt":"","text":"移动端H5页面调试移动端H5页面调试工具 vconsole 查看浏览器的兼容性 JS/CSS/HTML 兼容性问题都可以查看 https://canisue.com/","categories":[],"tags":[]},{"title":"es6基础","slug":"es6+","date":"2021-06-29T14:36:34.151Z","updated":"2021-06-29T14:36:34.151Z","comments":true,"path":"2021/06/29/es6+/","link":"","permalink":"https://shibin-cli.github.io/blog/2021/06/29/es6+/","excerpt":"","text":"部分内容参考了《ECMAScript 6 入门》 ES2015块级作用域在es6之前，只有两种作用域 全局作用域 函数作用域 es6新增了块级作用域，可以使用let和const声明 letlet 可以用来声明变量，它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 1234if (true) &#123; var a = 100&#125;console.log(a) //100 将变量a换成使用let或const声明后,就会报错 1234if (true) &#123; let a = 100&#125;console.log(a) //ReferenceError: a is not defined 如果使用let，声明的变量仅在块级作用域内有效 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。 不存在变量提升var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。但let或const声明的变量不存在变量提升 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 暂时性死区123456var tmp = 123;if (true) &#123; tmp = &#x27;abc&#x27;; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; constconst用来声明一个只读的常量。一旦声明，常量的值就不能改变。其他的跟let一样 12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only 在开发环境允许的条件下，声明变量时不要使用var，能用const就使用const，不能用就使用let 变量解构赋值数组的解构12345678let [a, b, c] = [1, 2, 3]console.log(a, b, c) // 1 2 3let [, , d] = [1, 2, 3]console.log(d) // 3let [, d] = [1]console.log(d) // undefined 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。如果匹配不成功，变量的值就是undefined 可以使用...来匹配剩余的元素 12let [e, , ...f] = [1, 2, 3, 4, 5, 6]console.log(f) // [ 3, 4, 5, 6 ] 默认值 1let [x, y = &#x27;b&#x27;] = [&#x27;a&#x27;]; // x=&#x27;a&#x27;, y=&#x27;b&#x27; 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 对象的解构12345678910111213lconst obj = &#123; name: &#x27;Shibin&#x27;, age: &#x27;17&#x27;&#125;let &#123; name, age &#125; = objconsole.log(name, age) //Shibin 17// 如果变量名与属性名不一致，可以这样写let &#123; name: MyName &#125; = objconsole.log(MyName)// 默认值let &#123; title: myTitle = &#x27;Hello&#x27; &#125; = objconsole.log(myTitle) //Hello 字符串模板字符串模板字符串中嵌入变量，需要将变量名写在${}之中。 123const name = &#x27;Shibin&#x27;const msg = `Hello,$&#123;name&#125;` console.log(msg) // Hello,Shibin 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。 1console.log(`1 + 2 = $&#123;1 + 2&#125;`) // 1 + 2 = 3 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 带标签的模板字符串模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串 12345678910const name = &#x27;Shibin&#x27;const age = &#x27;17&#x27;function myFunc(str, name, age) &#123; console.log(str) // [ &#x27;My name is &#x27;, &quot;. I&#x27;m &quot;, &#x27; years old&#x27; ] console.log(name, age) // Shibin 17 let old = age &gt; 1 ? `$&#123;age&#125; years old` : `$&#123;age&#125; year old` return str[0] + name + str[1] + old&#125;let res = myFunc`My name is $&#123;name&#125;. I&#x27;m $&#123;age&#125;`console.log(res) // My name is Shibin. I&#x27;m 1 year old 字符串方法 includes 是否包含xxx字符串 startsWith 是否以xxx开头 endsWith 是否以xxx结尾1234let a = &#x27;https//www.github.com&#x27;console.log(a.includes(&#x27;github&#x27;)) // trueconsole.log(a.startsWith(&#x27;https&#x27;)) // trueconsole.log(a.endsWith(&#x27;com&#x27;)) // true 参数默认值12345function log(x, y = &#x27;World&#x27;) &#123; console.log(x, y);&#125;log(&#x27;Hello&#x27;) // Hello World 通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。1234567function f(x = 1, y) &#123; return [x, y];&#125;f() // [1, undefined]f(2) // [2, undefined]f(, 1) // 报错 所以在使用开发过程中,一定要没有默认值的参数在前，有默认值的参数在后 可以使用…获取剩余的参数,也要放到最后再使用 1234function fn(a, ...b) &#123; console.log(b) // [ 2, 3, 4, 5 ]&#125;fn(1, 2, 3, 4, 5) 展开数组和对象1234567891011let a = [1, 2, 3, 4]console.log([...a]) // [ 1, 2, 3, 4 ]let obj = &#123; name: &#x27;Shibin&#x27;, age: &#x27;17&#x27;&#125;console.log(&#123; ...obj, sex: &#x27;boy&#x27;&#125;)//&#123; name: &#x27;Shibin&#x27;, age: &#x27;17&#x27;, sex: &#x27;boy&#x27; &#125; 箭头函数es6允许使用=&gt;定义函数 12345const fn = a =&gt; a// 等同于const fn = a =&gt; &#123; return a&#125; 如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 123let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;)// 报错let getTempItem = id =&gt; &#123; id: id, name: &quot;Temp&quot; &#125; 箭头函数不会改变this的指向，即函数内部this指向和函数外面this的指向一样 对象对象字面量当变量名与对象的属性名一样时，可以直接省略调冒号+属性值，写成下面的样子 12345678910111213141516const bar = &#x27;bar&#x27;const obj = &#123; foo: 123, bar, func()&#123; console.log(123) &#125;&#125;// 等价于const obj = &#123; foo: 123, bar: bar, func: func()&#123; console.log(123) &#125;&#125; 在声明对象时，还可以使用 [计算属性值]: 属性值来声明动态的属性值 1234567const obj = &#123; [&#x27;a&#x27; + &#x27;b&#x27;]: &#x27;aabb&#x27;&#125;// 等价于const obj = &#123; ab: &#x27;aabb&#x27;&#125; Object.assignObject.assign 将多个对象中的属性（可枚举属性）复制到一个目标对象中，后面的属性会覆盖前面的对象 123456789const obj1 = &#123; name: &#x27;Shibin&#x27;&#125;const obj2 = &#123; age: 17, sex: &#x27;boy&#x27;&#125;const target = Object.assign(obj1, obj2)console.log(target) // &#123; name: &#x27;Shibin&#x27;, age: 17, sex: &#x27;boy&#x27; &#125; Object.is判断两个变量是否相等 1console.log(Object.is(NaN, NaN)) //true ProxyProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截 12345678910111213141516171819202122const person = &#123; name: &#x27;Shibin&#x27;, age: 17&#125;const personProxy = new Proxy(person, &#123; get(target, key) &#123; console.log(target, key) // &#123; name: &#x27;Shibin&#x27;, age: 17 &#125; name return target[key] &#125;, set(target, key, val) &#123; console.log(target, key, val) if(key === &#x27;age&#x27; &amp;&amp; typeof val !== &#x27;number&#x27;)&#123; throw new Error(&#x27;age must be number&#x27;) &#125; target[key] = val // &#123; name: &#x27;Shibin&#x27;, age: 17 &#125; sex boy &#125;&#125;)console.log(personProxy.name)console.log(personProxy.age)personProxy.sex = &#x27;boy&#x27;age.age = &#x27;aa&#x27; //报错 Error: age must be number Proxy相对于Object.defineProperty的优势 可以监听对象的删除 更好的支持数组对象的监视12345678910const person = &#123; name: &#x27;Shibin&#x27;, age: 17&#125;const personProxy = new Proxy(person, &#123; deleteProperty(target, key) &#123; console.log(target, key) // &#123; name: &#x27;Shibin&#x27;, age: 17 &#125; age &#125;&#125;)delete personProxy.age 1234567891011const arr = [1, 2, 3, 4, 5]const personArr = new Proxy(arr, &#123; set(target, key, val) &#123; console.log(target, key, val) target[key] = val // [ 1, 2, 3, 4, 5 ] 5 6 // [ 1, 2, 3, 4, 5, 6 ] length 6 return true &#125;&#125;)personArr.push(6)console.log(arr) Proxy是以非侵入的方式监管了对象的读写 其他属性参考 https://es6.ruanyifeng.com/#docs/proxy ReflectReflect成员方法就是Proxy处理对象的默认实现。Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。 123456789101112let person = &#123; name: &#x27;Shibin&#x27;, age: 17&#125;const personProxy = new Proxy(person, &#123; get(target, key, receiver) &#123; return Reflect.set(target, key, receiver) &#125;, set(target, key, val, receiver) &#123; return Reflect.set(target, key, val, receiver) &#125;&#125;) 它统一提供了一套用于操作对象的API 一共提供了13个静态方法 Reflect.apply(target, thisArg, args) Reflect.construct(target, args) Reflect.get(target, name, receiver) Reflect.set(target, name, value, receiver) Reflect.defineProperty(target, name, desc) Reflect.deleteProperty(target, name) Reflect.has(target, name) Reflect.ownKeys(target) R*eflect.isExtensible(target) Reflect.preventExtensions(target) Reflect.getOwnPropertyDescriptor(target, name) Reflect.getPrototypeOf(target) Reflect.setPrototypeOf(target, prototype) Class1234567891011class Person &#123; constructor(name) &#123; this.name = name &#125; say() &#123; console.log(`Hello,my name is $&#123;this.name&#125;`) &#125;&#125;const person = new Person(&#x27;Tom&#x27;)person.say() // Hello,my name is Tom 如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 12345678910class Foo &#123; static classMethod() &#123; return &#x27;hello&#x27;; &#125;&#125;Foo.classMethod() // &#x27;hello&#x27;var foo = new Foo();foo.classMethod() Class的继承Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 12345678910111213141516171819202122class Person &#123; constructor(name) &#123; this.name = name &#125; say() &#123; console.log(`Hello,my name is $&#123;this.name&#125;`) &#125;&#125;class Student extends Person &#123; constructor(name, age) &#123; super(name) this.age = age &#125; sayAge() &#123; console.log(this.age) &#125;&#125;const student = new Student(&#x27;Tom&#x27;, 20)student.say() // Hello,my name is Tomstudent.sayAge() // 20 super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则新建实例时会报错 Set类似于数组，但是成员的值都是唯一的，没有重复的值。 123const a = new Set()a.add(1).add(2).add(3).add(3)console.log(a) // Set(3) &#123; 1, 2, 3 &#125; Set的方法 Set.prototype.add(value)：添加某个值，返回 Set 结构本身。 Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。 Set.prototype.clear()：清除所有成员，没有返回值。 Set.prototype.size：返回Set实例的成员总数。 Set的遍历操作 Set.prototype.keys()：返回键名的遍历器 Set.prototype.values()：返回键值的遍历器 Set.prototype.entries()：返回键值对的遍历器 Set.prototype.forEach()：使用回调函数遍历每个成员 Set转换为数组 12console.log(Array.from(a)) // [ 1, 2, 3 ]console.log([...a]) // [ 1, 2, 3 ] WeakSetWeakSet 结构与 Set 类似，也是不重复的值的集合.但是，它与 Set 有两个区别。 WeakSet 的成员只能是对象，而不能是其他类型的值。 WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用。也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。 这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。 这些特点同样适用于 WeakMap 结构。 Map它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。 12345678910const obj = &#123; name: &#x27;tom&#x27;&#125;const a = new Map()a.set(obj, 100)console.log(a) // Map(1) &#123; &#123; name: &#x27;tom&#x27; &#125; =&gt; 100 &#125;console.log(a.get(obj)) //100// 清除set中的内容a.clear() console.log(a) //Map(0) &#123;&#125; Map实例的属性方法 size 返回 Map 结构的成员总数。 Map.prototype.set(key, value) Map.prototype.get(key) Map.prototype.has(key) 表示某个键是否在当前 Map 对象之中 Map.prototype.delete(key) delete删除某个键，返回true。如果删除失败，返回false。 Map.prototype.clear() 清除所有成员 Symbol一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object） 12345678let a = Symbol(&#x27;123&#x27;)let b = Symbol(&#x27;123&#x27;)console.log(a === b) //falselet obj = &#123;&#125;obj[a] = 200obj[b] = 100console.log(obj) // &#123; [Symbol(123)]: 200, [Symbol(123)]: 100 &#125; 对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。 有时，我们希望重新使用同一个 Symbol 值,可以使用Symbol.for() 1234let s1 = Symbol.for(&#x27;foo&#x27;);let s2 = Symbol.for(&#x27;foo&#x27;);console.log(s1 === s2) // true Object.keys和for in循环无法获取到属性名为symbol的属性，可以使用getOwnPropertySymbols获取到属性名为symbol的属性 IteratorIterator 的作用有三个： 为各种数据结构，提供一个统一的、简便的访问接口 使得数据结构的成员能够按某种次序排列 ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费 Iterator 的遍历过程是这样的 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员 不断调用指针对象的next方法，直到它指向数据结构的结束位置 每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。 12345678910111213// 实现Iterator 接口const obj = &#123; [Symbol.iterator] : function () &#123; return &#123; next: function () &#123; return &#123; value: 1, done: true &#125;; &#125; &#125;; &#125;&#125; ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的” 原生具备 Iterator 接口的数据结构如下 Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定 for…of作为遍历所有数据结构的统一的方法。 12345678910111213141516171819202122232425262728293031const arr = [100, 200, 300, 400, 900]for (const item of arr) &#123; console.log(item)&#125;// 输出// 100// 200// 300// 400// 900let s = new Set(arr)for (const item of s) &#123; console.log(item)&#125;// 输出// 100// 200// 300// 400// 900let m = new Map()m.set(&#x27;name&#x27;,&#x27;tom&#x27;)m.set(&#x27;age&#x27;,20)for (const item of m) &#123; console.log(item)&#125;// 输出// [ &#x27;name&#x27;, &#x27;tom&#x27; ]// [ &#x27;age&#x27;, 20 ] 生成器在function关键字与函数名加上一个星号就是生成器函数，函数体内部可以使用yied表达式 1234567891011121314151617function* foo() &#123; console.log(&#x27;foo&#x27;) return &#x27;foo&#x27;&#125;let res = foo()console.log(res.next()) //&#123; value: &#x27;foo&#x27;, done: true &#125;function* foo() &#123; console.log(&#x27;foo&#x27;) yield &#x27;1&#x27; yield &#x27;2&#x27; return &#x27;foo&#x27;&#125;let res = foo()console.log(res.next()) //&#123; value: &#x27;1&#x27;, done: false &#125;console.log(res.next()) //&#123; value: &#x27;2&#x27;, done: false &#125; Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。 遍历器对象的next方法的运行逻辑如下。 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 如果该函数没有return语句，则返回的对象的value属性值为undefined。 yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。 123456789101112131415/*next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。*/function* f() &#123; for(var i = 0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125;&#125;var g = f();g.next() // &#123; value: 0, done: false &#125;g.next() // &#123; value: 1, done: false &#125;g.next(true) // &#123; value: 0, done: false &#125; ES2016Array.prototype.inclodes123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度 indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。 指数运算符1234// es5console.log(Math.pow(2, 4))// es2016console.log(2 ** 4) ES2017bject.values()返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。 12const obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;console.log(Object.values(obj)) // [ &#x27;bar&#x27;, 42 ] Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。 123const obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;Object.entries(obj)// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ] 如果原对象的属性名是一个 Symbol 值，该属性会被忽略。 1console.log(Object.entries(&#123; [Symbol()]: 123, foo: &#x27;abc&#x27; &#125;)) // [ [ &#x27;foo&#x27;, &#x27;abc&#x27; ] ] Object.entries的基本用途是遍历对象的属性。 123456const obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;for (const [k, v] of Object.entries(obj)) &#123; console.log(k, v)&#125;// foo bar// baz 42 Object.getOwnPropertyDescriptors返回指定对象所有自身属性（非继承属性）的描述对象。 123456789101112131415const f1 = &#123; name: &#x27;Shibin&#x27;, age: 10, get say() &#123; return this.name + &#x27;:&#x27; + this.age &#125;&#125;const f2 = Object.assign(&#123;&#125;, f1)f2.age = 17console.log(f2.say) //&#123; name: &#x27;Shibin&#x27;, age: 17, say: &#x27;Shibin:10&#x27; &#125;const descriptors = Object.getOwnPropertyDescriptors(f1)const f3 = Object.defineProperties(&#123;&#125;, descriptors)f3.age = 18console.log(f3.say) //Shibin:18 String.prototype.padEnd String.prototype.padStart字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 123const str=&#x27;123&#x27;console.log(str.padEnd(8, &#x27;0&#x27;)) // 12300000console.log(str.padStart(8, &#x27;0&#x27;)) // 00000123 伪逗号1234// 函数参数末尾添加伪逗号function fn1(a, b,) &#123;&#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}