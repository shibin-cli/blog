---
title: JavaScript性能优化
---
## 内存管理
为什么需要使用内存管理
### 内存管理介绍
内存: 有可读写单元组成，表示一片可操作空间

管理：人为的去操作一片空间的申请、使用和释放

内存管理：开发者主动申请空间、使用空间、释放空间

管理流程： 申请 -> 管理 -> 释放

``` js
// 申请
let obj = {}
// 使用
obj.name = 'aa'
// 释放
obj = null
```
### Javascript中的垃圾回收
* JavaScript中内存管理是自动的
* 对象在不被引用时时垃圾、对象不能从根上访问到时时垃圾

JavaScript中的可达对象
* 可以访问到的对象就是可达对象（引用、作用域链）
* 可达的标准就是从根出发是否能够被找到
* JavaScript中的根就可以理解为时全局变量对象

JavaScript中的引用与可达
``` js
let obj = {
    name: 'JavaScript'
}
let obj2 = obj
obj = null
```
上面代码中obj虽然obj赋值为null，但是obj2还在引用obj对象，所以obj依然是可达的

## GC算法
* GC就是垃圾回收机制的简写
* GC可以找到内存中的垃圾、并释放和回收空间

GC中的垃圾是什么
* 程序中不在需要使用的对象
* 程序中不能再访问到的对象

GC算法是什么
* GC算法是一种机制，垃圾回收器完成具体的工作
* 工作的内容就是查找垃圾释放空间、回收空间
* 算法是工作时查找和回收所遵循的规则

常见的GC算法
* 引用计数
* 标记清除
* 标记整理
* 分代回收

### 引用计数
* 引用计数的核心就是设置引用数，判断当前引用计数是否位0
* 引用关系发生改变时修改引用数字
* 引用数字为0时，立即回收

引用计数的优点
* 发现垃圾时立即回收
* 最大限度的减少程序的暂停

引用计数的缺点
* 无法回收循环引用的对象
* 资源开销大

下面代码就会引起循环引用
``` js
function fn() {
    const obj1 = {}
    const obj2 = {}
    obj1.name = obj2
    obj2.name = obj1
}
fn()
```
### 标记清除
分标记和清除两个阶段完成
* 遍历所有对象找标记活动对象（查询所有的可达对象进行标记）
* 遍历所有对象清除没有标记的对象
* 回收相应的空间

标记清除的优点
* 可以解决前面提到的对象引用的问题

标记清除的缺点
* 空间的碎片化
* 不能立即回收对象
### 标记整理
* 标记整理可以看做时标记清除的增强
* 标记阶段的操作和标记清除一致
* 清除阶段会先执行整理，移动对象位置

优点
* 减少空间碎片化
* 不能立即回收对象
## V8
* V8是一款主流的JavaScript执行引擎
* 采用即时编译
* V8内存设限

### V8垃圾回收策略
采用分代回收，内存分为新生代和老生代，针对不同对象采用不同的算法
* 新生代对象采用GC算法

V8常用的GC算法
* 分代回收
* 空间复制
* 标记清除
* 标记整理
* 标记增量
### V8内存分配
* V8内存空间一分为二
* 小空间用于存储新生代对象（32M | 16M）,新生代指的是存活时间较短的对象

### 新生代对象回收实现
* 回收过程采用复制算法+标记整理
* 新生代存储分为两个等大小空间
* 使用空间为from,空闲空间为to
* 活动对象存储与from空间，标记整理后活动对象拷贝至To
* from与to交换空间完成释放

回收过程细节说明
* 拷贝过程中会出现晋升，晋升就是将新生代对象移动至老生代
* 一轮GC还存活的的新生代需要晋升
* To空间的使用率超过25%需要晋升

### 老生代对象回收
老生代对象指的就是存活时间较长的对象

老生代对象限制：64位操作系统1.4G、32位操作系统700M

回收
* 只要采用标记清除、标记整理、标记增量算法
* 首先采用标记清除完成垃圾回收空间的清除
* 采用标记整理进行空间优化（晋升时触发）
* 采用增量标记进行效率优化

程序触发垃圾回收后，会遍历对象进行标记，之后标记和程序执行交替进行（将标记操作分成了多步，程序停顿的时间拆分成了多个小段），标记操作完成后，完成清除，程序继续执行
![标记增量回收过程](./images/1611306361.jpg)

新生代与老生代回收对比
* 新生代区域垃圾回收使用空间交换时间
* 老生代区域垃圾回收不适合复制算法

## Performance
GC的目的是为了实现内存空间的良性循环，Performance提供多种监控方式

打开浏览器控制台，选择Performance，开启录制功能

### 内存问题的外在表现
* 页面出现延迟加载或经常性暂停
* 页面出现出现持续糟糕的性能
* 页面的性能随着时间延长越来越差

### 监控内存的几种方式
界定内存问题的标准
* 内存泄漏：内存使用持续升高
* 内存膨胀：在多数设备上都存在性能问题
* 频繁的垃圾回收：通过内存变化图进行分析

内存监控的几种方式
* 浏览器的任务管理器（`shift + esc`）
* Timeline时序图记录
* 堆快照查找分离DOM（浏览器控制台>内存）

频繁的垃圾回收
* timtLine中频繁的上升或下降
* 任务管理器数据频繁的增加减少

## 代码优化
可通过 https://jsperf.com/ 对代码进行性能测试
### 慎用全局变量
为什么要慎用
* 全局变量定义在全局执行上下文，是所有作用域链的顶端
* 全局执行上下文一直存在于上下文执行栈，直到程序退出
* 如果某个局部作用域出现了同名变量则会遮蔽或污染全局
